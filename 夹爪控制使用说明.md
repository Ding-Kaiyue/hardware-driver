# 夹爪控制使用说明

## 编译

在 `/home/orin/hardware_ws` 目录下执行：

```bash
cd /home/orin/hardware_ws
colcon build --packages-select hardware_driver --cmake-args -DCMAKE_BUILD_TYPE=Release
```

编译成功后会生成以下文件：
- 库文件：`install/hardware_driver/lib/libhardware_driver_canfd.so`
- 头文件：`install/hardware_driver/include/hardware_driver/`
- 示例程序：`install/hardware_driver/lib/hardware_driver/example_gripper_control`

## 运行示例程序

```bash
# 首先 source 环境
source install/setup.bash

# 运行夹爪控制示例
./install/hardware_driver/lib/hardware_driver/example_gripper_control
```

**注意**：运行前需要确保 CAN 总线已经配置好（例如 can0）。如果没有实际硬件，程序会报错。

## 在你的代码中使用夹爪控制

### 1. 基本用法（通过 RobotHardware）

```cpp
#include "hardware_driver/interface/robot_hardware.hpp"
#include <map>
#include <vector>

int main() {
    // 创建电机驱动
    auto motor_driver = hardware_driver::createCanFdMotorDriver({"can0"});

    // 配置接口和电机ID（如果不需要控制电机，可以为空）
    std::map<std::string, std::vector<uint32_t>> interface_motor_config;
    interface_motor_config["can0"] = {};

    // 创建 RobotHardware 实例
    RobotHardware robot(motor_driver, interface_motor_config);

    // 控制 OmniPicker 夹爪
    robot.open_gripper("can0", 0, 50, 50);   // 0 = OmniPicker
    robot.close_gripper("can0", 0, 50, 80);  // 以 80% 的力关闭
    robot.control_gripper("can0", 0, 50, 50, 50);  // 自定义位置/速度/力

    // 控制 PGC 夹爪
    robot.open_gripper("can0", 1, 50, 50);   // 1 = PGC_Gripper
    robot.close_gripper("can0", 1, 50, 70);

    // 发送原始数据（Raw Frame 模式）
    uint8_t raw_data[] = {0x01, 0x02, 0x03};
    robot.send_gripper_raw_data("can0", raw_data, sizeof(raw_data));

    return 0;
}
```

### 2. 直接使用夹爪驱动接口

如果你只需要夹爪控制，不需要电机控制，可以直接使用夹爪驱动接口：

```cpp
#include "hardware_driver/driver/gripper_driver_interface.hpp"
#include "hardware_driver/interface/robot_hardware.hpp"  // 用于工厂函数

int main() {
    // 创建夹爪驱动
    auto gripper_driver = hardware_driver::createCanFdGripperDriver({"can0"});

    // 使用驱动控制夹爪
    using namespace hardware_driver::gripper_driver;

    gripper_driver->open_gripper("can0", GripperType::OmniPicker, 50, 50);
    gripper_driver->close_gripper("can0", GripperType::OmniPicker, 50, 80);
    gripper_driver->control_gripper("can0", GripperType::OmniPicker, 50, 50, 50);

    return 0;
}
```

### 3. 使用观察者模式接收夹爪状态

```cpp
#include "hardware_driver/driver/gripper_driver_interface.hpp"
#include "hardware_driver/interface/robot_hardware.hpp"
#include <iostream>

// 实现状态观察者
class MyGripperObserver : public hardware_driver::gripper_driver::GripperStatusObserver {
public:
    void on_gripper_status_update(const std::string& interface,
                                   uint32_t gripper_id,
                                   const hardware_driver::gripper_driver::GripperStatus& status) override {
        std::cout << "夹爪 " << interface << ":" << gripper_id
                  << " 位置:" << (int)status.position
                  << " 速度:" << (int)status.velocity
                  << " 力:" << (int)status.force
                  << " 是否夹持物体:" << (status.has_object ? "是" : "否")
                  << " 是否在移动:" << (status.is_moving ? "是" : "否")
                  << std::endl;
    }
};

int main() {
    auto gripper_driver = hardware_driver::createCanFdGripperDriver({"can0"});

    // 创建并添加观察者
    auto observer = std::make_shared<MyGripperObserver>();
    gripper_driver->add_observer(observer);

    // 控制夹爪...
    gripper_driver->open_gripper("can0",
                                 hardware_driver::gripper_driver::GripperType::OmniPicker,
                                 50, 50);

    // 等待接收反馈...
    std::this_thread::sleep_for(std::chrono::seconds(2));

    return 0;
}
```

## 支持的夹爪类型

| 夹爪类型 | 枚举值 | uint8_t值 | 说明 |
|---------|--------|-----------|------|
| OmniPicker | `GripperType::OmniPicker` | 0 | OmniPicker 全向夹爪 |
| PGC_Gripper | `GripperType::PGC_Gripper` | 1 | PGC 夹爪 |
| Raw_Frame | `GripperType::Raw_Frame` | 2 | 原始帧模式（透传数据）|

## 接口说明

### control_gripper - 控制夹爪

```cpp
void control_gripper(const std::string& interface,  // CAN 接口名（如 "can0"）
                    uint8_t gripper_type,           // 夹爪类型（0/1/2）
                    uint8_t position,               // 位置 (0-100%)
                    uint8_t velocity,               // 速度 (0-100%)
                    uint8_t effort);                // 力 (0-100%)
```

### open_gripper - 打开夹爪

```cpp
void open_gripper(const std::string& interface,     // CAN 接口名
                 uint8_t gripper_type,              // 夹爪类型
                 uint8_t velocity = 50,             // 速度（默认50%）
                 uint8_t effort = 50);              // 力（默认50%）
```

### close_gripper - 关闭夹爪

```cpp
void close_gripper(const std::string& interface,    // CAN 接口名
                  uint8_t gripper_type,             // 夹爪类型
                  uint8_t velocity = 50,            // 速度（默认50%）
                  uint8_t effort = 50);             // 力（默认50%）
```

### send_gripper_raw_data - 发送原始数据

```cpp
void send_gripper_raw_data(const std::string& interface,  // CAN 接口名
                          const uint8_t* raw_data,        // 原始数据指针
                          size_t raw_data_len);           // 数据长度
```

## CMakeLists.txt 配置

如果你要在自己的项目中使用这个库，需要在 `CMakeLists.txt` 中添加：

```cmake
# 查找包
find_package(hardware_driver REQUIRED)

# 添加可执行文件
add_executable(your_program your_program.cpp)

# 链接库
target_link_libraries(your_program
    hardware_driver::hardware_driver_canfd
)
```

## 架构说明

夹爪控制代码按照以下三层架构组织：

1. **协议层**（Protocol Layer）
   - `src/protocol/gripper_omnipicker_protocol.hpp/cpp`
   - 负责 CAN 帧的编码和解码
   - 支持 OmniPicker、PGC 和 Raw Frame 三种协议

2. **驱动层**（Driver Layer）
   - `include/hardware_driver/driver/gripper_driver_interface.hpp`（接口定义）
   - `src/driver/gripper_driver_impl.hpp/cpp`（具体实现）
   - 负责夹爪控制逻辑和状态管理
   - 使用观察者模式提供状态回调

3. **接口层**（Interface Layer）
   - `include/hardware_driver/interface/robot_hardware.hpp`
   - `src/interface/robot_hardware.cpp`
   - 提供统一的机器人硬件控制接口
   - 同时支持电机和夹爪控制

## 常见问题

### Q: 编译时找不到头文件？
A: 确保已经 source 了环境：`source install/setup.bash`

### Q: 运行时报 "Bus interface is nullptr"？
A: 检查 CAN 接口是否已经配置，例如执行：
```bash
sudo ip link set can0 type can bitrate 1000000
sudo ip link set can0 up
```

### Q: 如何查看是否收到夹爪反馈？
A: 使用观察者模式（参见上面的示例3），或者使用 `candump can0` 命令查看 CAN 总线数据。

### Q: 支持多个 CAN 接口吗？
A: 支持！创建驱动时可以传入多个接口，例如：
```cpp
auto gripper_driver = hardware_driver::createCanFdGripperDriver({"can0", "can1"});
```

## 相关文件

- 协议实现：`src/protocol/gripper_omnipicker_protocol.hpp/cpp`
- 驱动接口：`include/hardware_driver/driver/gripper_driver_interface.hpp`
- 驱动实现：`src/driver/gripper_driver_impl.hpp/cpp`
- 高层接口：`include/hardware_driver/interface/robot_hardware.hpp`
- 示例程序：`examples/example_gripper_control.cpp`
